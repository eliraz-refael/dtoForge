# ğŸ”¥ DtoForge

**OpenAPI to TypeScript Schema Generator with Runtime Validation**

DtoForge transforms your OpenAPI 3.0 specifications into type-safe TypeScript schemas with [io-ts](https://github.com/gcanti/io-ts) runtime validation. Perfect for creating validation gates when consuming external APIs.

[![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.21-007d9c.svg)](https://golang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Test](https://github.com/eliraz-refael/dtoForge/actions/workflows/test.yaml/badge.svg)](https://github.com/eliraz-refael/dtoForge/actions/workflows/test.yaml)

## âœ¨ Features

- ğŸš€ **Fast & Reliable** - Generate TypeScript schemas from OpenAPI 3.0 specs
- ğŸ›¡ï¸ **Runtime Validation** - Uses io-ts for type-safe runtime validation
- ğŸ¨ **Customizable Types** - Map OpenAPI formats to your custom branded types
- ğŸ“¦ **Zero Dependencies** - Single binary, no Node.js required
- ğŸ”§ **Extensible** - Plugin architecture for future language support
- ğŸ’¡ **Developer Friendly** - Rich error messages and helpful utilities
- ğŸ“ **Flexible Output** - Generate multiple files or single consolidated file
- âš™ï¸ **Configurable** - YAML-based configuration for defaults and customization

## ğŸš€ Quick Start

### Installation

**Download Binary (Recommended)**
```bash
# Download the latest release for your platform
curl -L https://github.com/eliraz-refael/dtoForge/releases/latest/download/dtoforge-linux -o dtoforge
chmod +x dtoforge
```

**Build from Source**
```bash
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge
go build -o dtoforge .
```

### Basic Usage

```bash
# Generate TypeScript schemas from OpenAPI spec
dtoforge -openapi api.yaml -out ./generated

# Use config file defaults (including output folder)
dtoforge -openapi api.yaml

# Specify custom package name
dtoforge -openapi api.yaml -out ./schemas -package my-api-types

# Use custom configuration
dtoforge -openapi api.yaml -config dtoforge.config.yaml
```

## ğŸ“– Examples

### Input: OpenAPI Specification

```yaml
# api.yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
components:
  schemas:
    User:
      type: object
      required:
        - id
        - email
        - name
      properties:
        id:
          type: string
          format: uuid
          description: Unique user identifier
        email:
          type: string
          format: email
          description: User's email address
        name:
          type: string
          description: Full name
        age:
          type: integer
          description: User's age (optional)
        createdAt:
          type: string
          format: date-time
          description: Account creation timestamp
        preferences:
          $ref: '#/components/schemas/UserPreferences'

    UserPreferences:
      type: object
      properties:
        theme:
          type: string
          enum: [light, dark, auto]
        notifications:
          type: boolean

    UserStatus:
      type: string
      enum: [active, inactive, pending, suspended]
```

### Generated Output (Multiple Files Mode)

**`generated/user.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
import * as t from 'io-ts';
import { DateFromISOString } from 'io-ts-types';

/**
 * A user in the system
 */
export const UserCodec = t.type({
  // Unique user identifier
  id: t.string,
  // User's email address
  email: t.string,
  // Full name
  name: t.string,
  // User's age (optional)
  age: t.union([t.number, t.undefined]),
  // Account creation timestamp
  createdAt: t.union([DateFromISOString, t.undefined]),
  preferences: t.union([UserPreferencesCodec, t.undefined]),
});

export type User = t.TypeOf<typeof UserCodec>;

// Validation helper
export const isUser = (value: unknown): value is User => 
  UserCodec.is(value);

// Decode helper with error handling
export const decodeUser = (value: unknown) => 
  UserCodec.decode(value);

// Partial codec for updates (all fields optional)
export const UserPartialCodec = t.partial({
  id: t.string,
  email: t.string,
  name: t.string,
  age: t.number,
  createdAt: DateFromISOString,
  preferences: UserPreferencesCodec,
});

export type UserPartial = t.TypeOf<typeof UserPartialCodec>;
```

**`generated/index.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
export * from './user';
export * from './user-preferences';
export * from './user-status';

// Re-export io-ts for convenience
export * as t from 'io-ts';
export { isLeft, isRight } from 'fp-ts/Either';

// Utility type for validation results
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  errors?: string[];
};

// Generic validation helper
export const validateData = <T>(
  codec: t.Type<T, any, unknown>,
  data: unknown
): ValidationResult<T> => {
  const result = codec.decode(data);
  
  if (isRight(result)) {
    return {
      success: true,
      data: result.right,
    };
  }
  
  return {
    success: false,
    errors: formatValidationErrors(result.left),
  };
};
```

### Generated Output (Single File Mode)

With `output.mode: "single"` in your config:

**`generated/schemas.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
// All schemas in a single file

import * as t from 'io-ts';
import { DateFromISOString } from 'io-ts-types';

// Schema: User
export const UserCodec = t.type({
  id: t.string,
  email: t.string,
  name: t.string,
  age: t.union([t.number, t.undefined]),
  createdAt: t.union([DateFromISOString, t.undefined]),
  preferences: t.union([UserPreferencesCodec, t.undefined]),
});

export type User = t.TypeOf<typeof UserCodec>;

// ... all other schemas, helpers, and utilities in one file
```

### Usage in Your Application

```typescript
import { UserCodec, validateData, User } from './generated';

// Validate API response
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  
  const result = validateData(UserCodec, data);
  
  if (!result.success) {
    throw new Error(`Invalid user data: ${result.errors?.join(', ')}`);
  }
  
  return result.data!; // TypeScript knows this is a valid User
}

// Type-safe API client
class UserApi {
  async getUser(id: string): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    
    // Runtime validation with detailed errors
    const decoded = UserCodec.decode(data);
    
    if (isLeft(decoded)) {
      const errors = decoded.left.map(err => err.message).join(', ');
      throw new Error(`API returned invalid user: ${errors}`);
    }
    
    return decoded.right; // Guaranteed to be a valid User
  }
}
```

## ğŸ”§ Configuration

### Complete Configuration File

Create a `dtoforge.config.yaml` file to customize generation behavior:

```yaml
# Output configuration
output:
  # Default output folder (can be overridden by -out flag)
  folder: "./generated"
  
  # Output mode: "multiple" (one file per DTO) or "single" (all in one file)
  mode: "multiple"
  
  # For single file mode, specify the filename
  singleFileName: "schemas.ts"

# Generation options
generation:
  # Whether to generate package.json
  generatePackageJson: true
  
  # Whether to generate partial codecs for updates
  generatePartialCodecs: true
  
  # Whether to generate validation helper functions
  generateHelpers: true

# Custom type mappings for OpenAPI formats
customTypes:
  # Date/Time formats with custom branded types
  date-time:
    ioTsType: "DateTimeString"
    typeScriptType: "DateTimeString"
    import: "import { DateTimeString } from './branded-types';"
  
  # UUID with branded type with validation
  uuid:
    ioTsType: "UUID"
    typeScriptType: "UUID"
    import: "import { UUID } from './branded-types';"
  
  # Email with branded type
  email:
    ioTsType: "EmailString"
    typeScriptType: "EmailString"
    import: "import { EmailString } from './branded-types';"
```

### Output Modes

#### Multiple Files Mode (Default)
```yaml
output:
  mode: "multiple"
```

Generates:
- `user.ts`, `product.ts`, etc. (one per schema)
- `index.ts` (exports everything)
- `package.json`

#### Single File Mode
```yaml
output:
  mode: "single"
  singleFileName: "api-schemas.ts"
```

Generates:
- `api-schemas.ts` (all schemas in one file)
- `package.json` (optional)

### Custom Type Mappings

**Create your branded types** (`branded-types.ts`):
```typescript
import * as t from 'io-ts';

// UUID with validation
export interface UUIDBrand {
  readonly UUID: unique symbol;
}

export type UUID = t.Branded<string, UUIDBrand>;

export const UUID = t.brand(
  t.string,
  (s): s is UUID => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s),
  'UUID'
);

// Email with validation
export interface EmailBrand {
  readonly Email: unique symbol;
}

export type EmailString = t.Branded<string, EmailBrand>;

export const EmailString = t.brand(
  t.string,
  (s): s is EmailString => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s),
  'EmailString'
);
```

### Generate Example Config

```bash
dtoforge -example-config
```

This creates a `dtoforge.config.yaml` with common customizations and all available options.

## ğŸ“š CLI Reference

```
DtoForge - OpenAPI to io-ts code generator

Usage: dtoforge [options]

Options:
  -openapi string
        Path to the OpenAPI spec file (JSON or YAML)
  -out string
        Output folder for generated files (default "./generated")
        Note: Config file can set a different default
  -lang string
        Target language (default "typescript")
  -package string
        Package/module name (optional)
  -config string
        Path to dtoforge config file (optional)
  -example-config
        Generate example dtoforge.config.yaml and exit

Config file discovery (if -config not specified):
  1. ./dtoforge.config.yaml (current directory)
  2. Same directory as OpenAPI file
  3. Same directory as binary

Example config file can be generated with: dtoforge -example-config
```

## ğŸ¯ Use Cases

### API Client Libraries
```typescript
// Generated schemas ensure API responses match expectations
class ApiClient {
  async fetchUsers(): Promise<User[]> {
    const data = await this.get('/users');
    return data.map(user => {
      const result = UserCodec.decode(user);
      if (isLeft(result)) {
        throw new Error('Invalid user data from API');
      }
      return result.right;
    });
  }
}
```

### Form Validation
```typescript
// Use partial codecs for form validation
const UserFormCodec = t.partial({
  name: t.string,
  email: EmailString,
  age: t.number,
});

function validateUserForm(formData: unknown) {
  return validateData(UserFormCodec, formData);
}
```

### Data Processing Pipelines
```typescript
// Validate data at pipeline boundaries
function processUsers(rawData: unknown[]): User[] {
  return rawData
    .map(data => UserCodec.decode(data))
    .filter(isRight)
    .map(result => result.right);
}
```

### Single File for Small Projects
```typescript
// When using single file mode, everything is in one place
import { UserCodec, ProductCodec, validateData } from './schemas';

// All your schemas are immediately available
const userData = validateData(UserCodec, apiResponse);
```

## ğŸ—ï¸ Architecture

DtoForge uses a plugin-based architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   OpenAPI       â”‚    â”‚  Intermediate    â”‚    â”‚    TypeScript      â”‚
â”‚   Parser        â”‚â”€â”€â”€â”€â”‚  Representation  â”‚â”€â”€â”€â”€â”‚    Generator       â”‚
â”‚                 â”‚    â”‚     (IR)         â”‚    â”‚    (io-ts)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â”œâ”€â”€ Future: C# Generator
                                â””â”€â”€ Future: Java Generator
```

This makes it easy to add support for other target languages in the future.

## ğŸ¤ Contributing

We welcome contributions! Here's how to get started:

### Development Setup

```bash
# Clone the repository
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge

# Install dependencies
go mod download

# Run tests
go test ./...

# Build locally
go build -o dtoforge .
```

### Running Tests

```bash
# Unit tests
go test -v ./internal/...

# Integration tests
go test -v ./integration_test.go

# Golden file tests (creates baseline)
UPDATE_GOLDEN=true go test -v -run TestGoldenFilesWithUpdate

# All tests
go test -v ./...
```

### Adding New Features

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/my-feature`
3. **Add tests** for your changes
4. **Run tests**: `go test ./...`
5. **Submit** a pull request

## ğŸ“‹ Roadmap

- [ ] **C# Generator** - Generate C# classes with validation
- [ ] **Java Generator** - Generate Java POJOs with Bean Validation
- [ ] **Advanced OpenAPI Features** - Support for `allOf`, `oneOf`, `anyOf`
- [ ] **JSON Schema Support** - Direct JSON Schema input
- [ ] **OpenAPI 3.1 Support** - Latest specification features

## ğŸ› Troubleshooting

### Common Issues

**Q: Generated files have import errors**
```bash
# Make sure your branded-types.ts file exports the correct types
# Check the import paths in your config file
```

**Q: Validation always fails**
```typescript
// Check that your data structure matches the schema
console.log(UserCodec.decode(data)); // See detailed error information
```

**Q: Config file not found**
```bash
# DtoForge looks for config in these locations:
# 1. Current directory: ./dtoforge.config.yaml
# 2. Same directory as OpenAPI file
# 3. Same directory as binary
# Or specify explicitly: -config path/to/config.yaml
```

**Q: Single file mode not working**
```yaml
# Make sure your config has the correct output mode:
output:
  mode: "single"
  singleFileName: "schemas.ts"  # optional, defaults to "schemas.ts"
```

**Q: Config output folder ignored**
```bash
# Config output folder is only used if you don't specify -out flag
# This works (uses config): dtoforge -openapi api.yaml
# This ignores config: dtoforge -openapi api.yaml -out ./custom
```

## ğŸ“„ License

MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- [io-ts](https://github.com/gcanti/io-ts) - Excellent runtime type validation library
- [fp-ts](https://github.com/gcanti/fp-ts) - Functional programming utilities
- The OpenAPI community for the great specification

---

## ğŸ’– Support DtoForge

If DtoForge saves you time and makes your development workflow better, consider supporting its development:

<div align="center">

[![Ko-fi](https://img.shields.io/badge/Ko--fi-F16061?style=for-the-badge&logo=ko-fi&logoColor=white)](https://ko-fi.com/elirazkedmi)

**Every contribution helps keep this project alive and growing! ğŸš€**

</div>

### Why Support DtoForge?

- ğŸ› ï¸ **Active Development** - Regular updates and new features
- ğŸ› **Bug Fixes** - Quick response to issues and problems  
- ğŸ“š **Documentation** - Comprehensive guides and examples
- ğŸ’¡ **Feature Requests** - Your ideas shape the future of DtoForge
- âš¡ **Performance** - Continuous optimization and improvements

### What Your Support Enables:

- More time for development and maintenance
- Better documentation and tutorials
- Additional language generators (C#, Java, Python)
- Community support and faster issue resolution

---

*DtoForge is an open source project built with â¤ï¸ by developers, for developers.*

**Made with â¤ï¸ by developers, for developers**

*DtoForge helps you build type-safe applications by bridging the gap between API specifications and runtime validation. Whether you prefer multiple organized files or a single consolidated schema file, DtoForge adapts to your project structure.*
