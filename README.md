# üî• DtoForge

**OpenAPI to TypeScript Schema Generator with Runtime Validation**

DtoForge transforms your OpenAPI 3.0 specifications into type-safe TypeScript schemas with runtime validation. Choose between [io-ts](https://github.com/gcanti/io-ts) for functional programming or [Zod](https://github.com/colinhacks/zod) for modern TypeScript validation.

[![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.21-007d9c.svg)](https://golang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Test](https://github.com/eliraz-refael/dtoForge/actions/workflows/test.yaml/badge.svg)](https://github.com/eliraz-refael/dtoForge/actions/workflows/test.yaml)

## ‚ú® Features

- üöÄ **Fast & Reliable** - Generate TypeScript schemas from OpenAPI 3.0 specs
- üõ°Ô∏è **Runtime Validation** - Choose between io-ts (functional) or Zod (modern) validation
- üé® **Customizable Types** - Map OpenAPI formats to your custom branded types
- üì¶ **Zero Dependencies** - Single binary, no Node.js required
- üîß **Extensible** - Plugin architecture for future language support
- üí° **Developer Friendly** - Rich error messages and helpful utilities
- üìÅ **Flexible Output** - Generate multiple files or single consolidated file
- ‚öôÔ∏è **Configurable** - YAML-based configuration for defaults and customization

## üöÄ Quick Start

### Installation

**Download Binary (Recommended)**
```bash
# Download the latest release for your platform
curl -L https://github.com/eliraz-refael/dtoForge/releases/latest/download/dtoforge-linux -o dtoforge
chmod +x dtoforge
```

**Build from Source**
```bash
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge
go build -o dtoforge .
```

### Basic Usage

```bash
# Generate TypeScript schemas with io-ts (default)
dtoforge -openapi api.yaml -out ./generated

# Generate TypeScript schemas with Zod
dtoforge -openapi api.yaml -lang typescript-zod -out ./generated

# Use config file defaults (including output folder)
dtoforge -openapi api.yaml

# Specify custom package name
dtoforge -openapi api.yaml -out ./schemas -package my-api-types

# Use custom configuration
dtoforge -openapi api.yaml -config dtoforge.config.yaml
```

## üìñ Examples

### Input: OpenAPI Specification

```yaml
# api.yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
components:
  schemas:
    User:
      type: object
      required:
        - id
        - email
        - name
      properties:
        id:
          type: string
          format: uuid
          description: Unique user identifier
        email:
          type: string
          format: email
          description: User's email address
        name:
          type: string
          description: Full name
        age:
          type: integer
          description: User's age (optional)
        createdAt:
          type: string
          format: date-time
          description: Account creation timestamp

    UserStatus:
      type: string
      enum: [active, inactive, pending, suspended]
```

### Generated Output: TypeScript with io-ts

**`generated/user.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
import * as t from 'io-ts';
import { DateFromISOString } from 'io-ts-types';

/**
 * User information
 */
export const UserCodec = t.type({
  // Unique user identifier
  id: t.string,
  // User's email address
  email: t.string,
  // Full name
  name: t.string,
  // User's age (optional)
  age: t.union([t.number, t.undefined]),
  // Account creation timestamp
  createdAt: t.union([DateFromISOString, t.undefined]),
});

export type User = t.TypeOf<typeof UserCodec>;

// Validation helper
export const isUser = (value: unknown): value is User => 
  UserCodec.is(value);

// Decode helper with error handling
export const decodeUser = (value: unknown) => 
  UserCodec.decode(value);

// Partial codec for updates (all fields optional)
export const UserPartialCodec = t.partial({
  id: t.string,
  email: t.string,
  name: t.string,
  age: t.number,
  createdAt: DateFromISOString,
});

export type UserPartial = t.TypeOf<typeof UserPartialCodec>;
```

### Generated Output: TypeScript with Zod

**`generated/user.ts`**
```typescript
// Generated by DtoForge (Zod) - DO NOT EDIT
import { z } from 'zod';

/**
 * User information
 */
export const UserSchema = z.object({
  // Unique user identifier
  id: z.string().uuid(),
  // User's email address
  email: z.string().email(),
  // Full name
  name: z.string(),
  // User's age (optional)
  age: z.number().optional(),
  // Account creation timestamp
  createdAt: z.string().datetime().optional(),
});

export type User = z.infer<typeof UserSchema>;
```

**`generated/user-status.ts`**
```typescript
// Generated by DtoForge (Zod) - DO NOT EDIT
import { z } from 'zod';

// Enum: UserStatus
export const UserStatusSchema = z.enum([
  'active',
  'inactive',
  'pending',
  'suspended'
]);

export type UserStatus = z.infer<typeof UserStatusSchema>;
```

### Usage in Your Application

**With io-ts:**
```typescript
import { UserCodec, validateData, User } from './generated';

// Validate API response
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  
  const result = validateData(UserCodec, data);
  
  if (!result.success) {
    throw new Error(`Invalid user data: ${result.errors?.join(', ')}`);
  }
  
  return result.data!; // TypeScript knows this is a valid User
}
```

**With Zod:**
```typescript
import { UserSchema, User } from './generated';

// Validate API response
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  
  const result = UserSchema.safeParse(data);
  
  if (!result.success) {
    throw new Error(`Invalid user data: ${result.error.message}`);
  }
  
  return result.data; // TypeScript knows this is a valid User
}

// Or use parse() for throwing validation
async function fetchUserStrict(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  
  return UserSchema.parse(data); // Throws ZodError if invalid
}
```

## üîß Configuration

### Complete Configuration File

Create a `dtoforge.config.yaml` file to customize generation behavior:

**For TypeScript with io-ts:**
```yaml
# TypeScript with io-ts configuration
typescript:
  output:
    folder: "./generated"
    mode: "multiple" # or "single"
    singleFileName: "schemas.ts"
  
  generation:
    generatePackageJson: true
    generatePartialCodecs: true
    generateHelpers: true
  
  customTypes:
    date-time:
      ioTsType: "DateTimeString"
      typeScriptType: "DateTimeString"
      import: "import { DateTimeString } from './branded-types';"
    
    uuid:
      ioTsType: "UUID"
      typeScriptType: "UUID"
      import: "import { UUID } from './branded-types';"
```

**For TypeScript with Zod:**
```yaml
# TypeScript with Zod configuration
typescript-zod:
  output:
    folder: "./generated"
    mode: "multiple" # or "single"
    singleFileName: "schemas.ts"
  
  generation:
    generatePackageJson: true
    generateHelpers: true
  
  customTypes:
    date-time:
      zodType: "DateTimeSchema"
      typeScriptType: "DateTime"
      import: "import { DateTimeSchema } from './datetime-utils';"
    
    uuid:
      zodType: "z.string().uuid().brand('UUID')"
      typeScriptType: "UUID"
      import: "import { UUID } from './branded-types';"
    
    email:
      zodType: "EmailSchema"
      typeScriptType: "Email"
      import: "import { EmailSchema } from './branded-types';"
```

### Output Modes

#### Multiple Files Mode (Default)
```yaml
output:
  mode: "multiple"
```

Generates:
- `user.ts`, `product.ts`, etc. (one per schema)
- `index.ts` (exports everything)
- `package.json`

#### Single File Mode
```yaml
output:
  mode: "single"
  singleFileName: "api-schemas.ts"
```

Generates:
- `api-schemas.ts` (all schemas in one file)
- `package.json` (optional)

### Custom Type Mappings

**Create your branded types** (`branded-types.ts`):

**For io-ts:**
```typescript
import * as t from 'io-ts';

// UUID with validation
export interface UUIDBrand {
  readonly UUID: unique symbol;
}

export type UUID = t.Branded<string, UUIDBrand>;

export const UUID = t.brand(
  t.string,
  (s): s is UUID => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s),
  'UUID'
);
```

**For Zod:**
```typescript
import { z } from 'zod';

// UUID with branded type
export const UUID = z.string().uuid().brand('UUID');
export type UUID = z.infer<typeof UUID>;

// Email with branded type
export const EmailSchema = z.string().email().brand('Email');
export type Email = z.infer<typeof EmailSchema>;

// DateTime with branded type
export const DateTimeSchema = z.string().datetime().brand('DateTime');
export type DateTime = z.infer<typeof DateTimeSchema>;
```

### Generate Example Config

```bash
dtoforge -example-config
```

This creates a `dtoforge.config.yaml` with common customizations and all available options.

## üìö CLI Reference

```
DtoForge - OpenAPI to TypeScript schema generator

Usage: dtoforge [options]

Options:
  -openapi string
        Path to the OpenAPI spec file (JSON or YAML)
  -out string
        Output folder for generated files (default "./generated")
        Note: Config file can set a different default
  -lang string
        Target language:
          typescript     - TypeScript with io-ts validation (default)
          typescript-zod - TypeScript with Zod validation
  -package string
        Package/module name (optional)
  -config string
        Path to dtoforge config file (optional)
  -no-config
        Disable automatic config file discovery
  -example-config
        Generate example dtoforge.config.yaml and exit

Config file discovery (if -config not specified and -no-config not set):
  1. ./dtoforge.config.yaml (current directory)
  2. Same directory as OpenAPI file
  3. Same directory as binary

Example config file can be generated with: dtoforge -example-config
```

## üéØ Choosing Between io-ts and Zod

### Use **TypeScript with io-ts** (`typescript`) when:
- ‚úÖ You prefer **functional programming** patterns
- ‚úÖ You need **excellent performance** (one of the fastest validators)
- ‚úÖ You want **mature, battle-tested** validation (used in production for years)
- ‚úÖ You're working with **fp-ts** ecosystem
- ‚úÖ You need **branded types** and advanced type-level programming

### Use **TypeScript with Zod** (`typescript-zod`) when:
- ‚úÖ You prefer **modern, intuitive** API design
- ‚úÖ You want **great developer experience** with excellent error messages
- ‚úÖ You need **built-in validators** (email, URL, date, etc.)
- ‚úÖ You're using **tRPC, Prisma**, or other Zod-first tools
- ‚úÖ You want **simpler, more readable** generated code

Both options provide excellent runtime validation and type safety!

## üéØ Use Cases

### API Client Libraries
```typescript
// With Zod
class ApiClient {
  async fetchUsers(): Promise<User[]> {
    const data = await this.get('/users');
    return data.map(user => UserSchema.parse(user));
  }
}

// With io-ts
class ApiClient {
  async fetchUsers(): Promise<User[]> {
    const data = await this.get('/users');
    return data.map(user => {
      const result = UserCodec.decode(user);
      if (isLeft(result)) {
        throw new Error('Invalid user data from API');
      }
      return result.right;
    });
  }
}
```

### Form Validation
```typescript
// With Zod - Built-in partial support
const UserFormSchema = UserSchema.partial();

function validateUserForm(formData: unknown) {
  return UserFormSchema.safeParse(formData);
}

// With io-ts - Generated partial codecs
function validateUserForm(formData: unknown) {
  return validateData(UserPartialCodec, formData);
}
```

### Single File for Small Projects
```typescript
// When using single file mode, everything is in one place
import { UserSchema, ProductSchema } from './schemas';

// All your schemas are immediately available
const userData = UserSchema.parse(apiResponse);
const productData = ProductSchema.parse(productResponse);
```

## üèóÔ∏è Architecture

DtoForge uses a plugin-based architecture:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   OpenAPI       ‚îÇ    ‚îÇ  Intermediate    ‚îÇ    ‚îÇ    TypeScript      ‚îÇ
‚îÇ   Parser        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ  Representation  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ    Generators      ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ     (IR)         ‚îÇ    ‚îÇ   (io-ts & Zod)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                ‚îÇ
                                ‚îú‚îÄ‚îÄ Future: C# Generator
                                ‚îî‚îÄ‚îÄ Future: Java Generator
```

This makes it easy to add support for other target languages in the future.

## ü§ù Contributing

We welcome contributions! Here's how to get started:

### Development Setup

```bash
# Clone the repository
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge

# Install dependencies
go mod download

# Run tests
go test ./...

# Build locally
go build -o dtoforge .
```

### Running Tests

```bash
# Unit tests
go test -v ./internal/...

# Integration tests
go test -v ./integration_test.go

# Golden file tests (creates baseline)
UPDATE_GOLDEN=true go test -v -run TestGoldenFilesWithUpdate

# All tests
go test -v ./...
```

### Adding New Features

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/my-feature`
3. **Add tests** for your changes
4. **Run tests**: `go test ./...`
5. **Submit** a pull request

## üìã Roadmap

### TypeScript Validator Libraries
- [ ] **Effect Schema** - Generate schemas with Effect's powerful validation system
- [ ] **Valibot** - Generate schemas with Valibot's modern approach
- [ ] **Superstruct** - Generate schemas with Superstruct validation
- [ ] **Yup** - Generate schemas with Yup validation library

### OpenAPI & Standards Support  
- [ ] **Advanced OpenAPI Features** - Support for `allOf`, `oneOf`, `anyOf`
- [ ] **OpenAPI 3.1 Support** - Latest specification features
- [ ] **JSON Schema Support** - Direct JSON Schema input

### Developer Experience
- [ ] **Enhanced Custom Types** - More flexible type mapping system
- [ ] **Schema Composition** - Better handling of complex nested schemas
- [ ] **Template Customization** - User-defined output templates

## üêõ Troubleshooting

### Common Issues

**Q: Generated files have import errors**
```bash
# Make sure your branded-types.ts file exports the correct types
# Check the import paths in your config file
```

**Q: Validation always fails**
```typescript
// For Zod: Check error details
const result = UserSchema.safeParse(data);
if (!result.success) {
  console.log(result.error.issues);
}

// For io-ts: Check detailed error information
console.log(UserCodec.decode(data)); // See detailed error information
```

**Q: Config file not found**
```bash
# DtoForge looks for config in these locations:
# 1. Current directory: ./dtoforge.config.yaml
# 2. Same directory as OpenAPI file
# 3. Same directory as binary
# Or specify explicitly: -config path/to/config.yaml
```

**Q: Single file mode not working**
```yaml
# Make sure your config has the correct output mode:
typescript-zod:  # or 'typescript' for io-ts
  output:
    mode: "single"
    singleFileName: "schemas.ts"  # optional, defaults to "schemas.ts"
```

**Q: Config output folder ignored**
```bash
# Config output folder is only used if you don't specify -out flag
# This works (uses config): dtoforge -openapi api.yaml
# This ignores config: dtoforge -openapi api.yaml -out ./custom
```

## üìÑ License

MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- [io-ts](https://github.com/gcanti/io-ts) - Excellent runtime type validation library
- [Zod](https://github.com/colinhacks/zod) - Modern TypeScript schema validation with great DX
- [fp-ts](https://github.com/gcanti/fp-ts) - Functional programming utilities
- The OpenAPI community for the great specification

---

## üíñ Support DtoForge

If DtoForge saves you time and makes your development workflow better, consider supporting its development:

<div align="center">

[![Ko-fi](https://img.shields.io/badge/Ko--fi-F16061?style=for-the-badge&logo=ko-fi&logoColor=white)](https://ko-fi.com/elirazkedmi)

**Every contribution helps keep this project alive and growing! üöÄ**

</div>

### Why Support DtoForge?

- üõ†Ô∏è **Active Development** - Regular updates and new features
- üêõ **Bug Fixes** - Quick response to issues and problems  
- üìö **Documentation** - Comprehensive guides and examples
- üí° **Feature Requests** - Your ideas shape the future of DtoForge
- ‚ö° **Performance** - Continuous optimization and improvements

### What Your Support Enables:

- More time for development and maintenance
- Better documentation and tutorials
- Additional language generators (C#, Java, Python)
- Community support and faster issue resolution

---

*DtoForge is an open source project built with ‚ù§Ô∏è by developers, for developers.*

**Made with ‚ù§Ô∏è by developers, for developers**

*DtoForge helps you build type-safe applications by bridging the gap between API specifications and runtime validation. Whether you prefer functional programming with io-ts or modern validation with Zod, DtoForge adapts to your development style and project needs.*
