# 🔥 DtoForge

**OpenAPI to TypeScript Schema Generator with Runtime Validation**

DtoForge transforms your OpenAPI 3.0 specifications into type-safe TypeScript schemas with [io-ts](https://github.com/gcanti/io-ts) runtime validation. Perfect for creating validation gates when consuming external APIs.

[![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.21-007d9c.svg)](https://golang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Build Status](https://github.com/eliraz-refael/dtoForge/workflows/test/badge.svg)](https://github.com/eliraz-refael/dtoForge/actions)

## ✨ Features

- 🚀 **Fast & Reliable** - Generate TypeScript schemas from OpenAPI 3.0 specs
- 🛡️ **Runtime Validation** - Uses io-ts for type-safe runtime validation
- 🎨 **Customizable Types** - Map OpenAPI formats to your custom branded types
- 📦 **Zero Dependencies** - Single binary, no Node.js required
- 🔧 **Extensible** - Plugin architecture for future language support
- 💡 **Developer Friendly** - Rich error messages and helpful utilities

## 🚀 Quick Start

### Installation

**Download Binary (Recommended)**
```bash
# Download the latest release for your platform
curl -L https://github.com/eliraz-refael/dtoForge/releases/latest/download/dtoforge-linux -o dtoforge
chmod +x dtoforge
```

**Build from Source**
```bash
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge
go build -o dtoforge .
```
    
### Basic Usage

```bash
# Generate TypeScript schemas from OpenAPI spec
dtoforge -openapi api.yaml -out ./generated

# Specify custom package name
dtoforge -openapi api.yaml -out ./schemas -package my-api-types

# Use custom type mappings
dtoforge -openapi api.yaml -config dtoforge.config.yaml -out ./generated
```

## 📖 Examples

### Input: OpenAPI Specification

```yaml
# api.yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
components:
  schemas:
    User:
      type: object
      required:
        - id
        - email
        - name
      properties:
        id:
          type: string
          format: uuid
          description: Unique user identifier
        email:
          type: string
          format: email
          description: User's email address
        name:
          type: string
          description: Full name
        age:
          type: integer
          description: User's age (optional)
        createdAt:
          type: string
          format: date-time
          description: Account creation timestamp
        preferences:
          $ref: '#/components/schemas/UserPreferences'

    UserPreferences:
      type: object
      properties:
        theme:
          type: string
          enum: [light, dark, auto]
        notifications:
          type: boolean

    UserStatus:
      type: string
      enum: [active, inactive, pending, suspended]
```

### Generated Output

**`generated/user.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
import * as t from 'io-ts';
import { DateFromISOString } from 'io-ts-types';

/**
 * A user in the system
 */
export const UserCodec = t.type({
  // Unique user identifier
  id: t.string,
  // User's email address
  email: t.string,
  // Full name
  name: t.string,
  // User's age (optional)
  age: t.union([t.number, t.undefined]),
  // Account creation timestamp
  createdAt: t.union([DateFromISOString, t.undefined]),
  preferences: t.union([UserPreferencesCodec, t.undefined]),
});

export type User = t.TypeOf<typeof UserCodec>;

// Validation helper
export const isUser = (value: unknown): value is User => 
  UserCodec.is(value);

// Decode helper with error handling
export const decodeUser = (value: unknown) => 
  UserCodec.decode(value);

// Partial codec for updates (all fields optional)
export const UserPartialCodec = t.partial({
  id: t.string,
  email: t.string,
  name: t.string,
  age: t.number,
  createdAt: DateFromISOString,
  preferences: UserPreferencesCodec,
});

export type UserPartial = t.TypeOf<typeof UserPartialCodec>;
```

**`generated/index.ts`**
```typescript
// Generated by DtoForge - DO NOT EDIT
export * from './user';
export * from './user-preferences';
export * from './user-status';

// Re-export io-ts for convenience
export * as t from 'io-ts';
export { isLeft, isRight } from 'fp-ts/Either';

// Utility type for validation results
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  errors?: string[];
};

// Generic validation helper
export const validateData = <T>(
  codec: t.Type<T, any, unknown>,
  data: unknown
): ValidationResult<T> => {
  const result = codec.decode(data);
  
  if (isRight(result)) {
    return {
      success: true,
      data: result.right,
    };
  }
  
  return {
    success: false,
    errors: formatValidationErrors(result.left),
  };
};
```

### Usage in Your Application

```typescript
import { UserCodec, validateData, User } from './generated';

// Validate API response
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  const data = await response.json();
  
  const result = validateData(UserCodec, data);
  
  if (!result.success) {
    throw new Error(`Invalid user data: ${result.errors?.join(', ')}`);
  }
  
  return result.data!; // TypeScript knows this is a valid User
}

// Type-safe API client
class UserApi {
  async getUser(id: string): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    const data = await response.json();
    
    // Runtime validation with detailed errors
    const decoded = UserCodec.decode(data);
    
    if (isLeft(decoded)) {
      const errors = decoded.left.map(err => err.message).join(', ');
      throw new Error(`API returned invalid user: ${errors}`);
    }
    
    return decoded.right; // Guaranteed to be a valid User
  }
}
```

## 🔧 Configuration

### Custom Type Mappings

Create a `dtoforge.config.yaml` file to customize how OpenAPI formats map to TypeScript types:

```yaml
customTypes:
  # Map date-time to custom branded type
  date-time:
    ioTsType: "DateTimeString"
    typeScriptType: "DateTimeString"
    import: "import { DateTimeString } from './branded-types';"
  
  # Map UUID to branded type with validation
  uuid:
    ioTsType: "UUID"
    typeScriptType: "UUID"
    import: "import { UUID } from './branded-types';"
  
  # Map email to branded type
  email:
    ioTsType: "EmailString"
    typeScriptType: "EmailString"
    import: "import { EmailString } from './branded-types';"
```

**Create your branded types** (`branded-types.ts`):
```typescript
import * as t from 'io-ts';

// UUID with validation
export interface UUIDBrand {
  readonly UUID: unique symbol;
}

export type UUID = t.Branded<string, UUIDBrand>;

export const UUID = t.brand(
  t.string,
  (s): s is UUID => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(s),
  'UUID'
);

// Email with validation
export interface EmailBrand {
  readonly Email: unique symbol;
}

export type EmailString = t.Branded<string, EmailBrand>;

export const EmailString = t.brand(
  t.string,
  (s): s is EmailString => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s),
  'EmailString'
);
```

### Generate Example Config

```bash
dtoforge -example-config
```

This creates a `dtoforge.config.yaml` with common customizations.

## 📚 CLI Reference

```
DtoForge - OpenAPI to io-ts code generator

Usage: dtoforge [options]

Options:
  -openapi string
        Path to the OpenAPI spec file (JSON or YAML)
  -out string
        Output folder for generated files (default "./generated")
  -lang string
        Target language (default "typescript")
  -package string
        Package/module name (optional)
  -config string
        Path to dtoforge config file (optional)
  -example-config
        Generate example dtoforge.config.yaml and exit

Config file discovery (if -config not specified):
  1. ./dtoforge.config.yaml (current directory)
  2. Same directory as OpenAPI file
  3. Same directory as binary

Example config file can be generated with: dtoforge -example-config
```

## 🎯 Use Cases

### API Client Libraries
```typescript
// Generated schemas ensure API responses match expectations
class ApiClient {
  async fetchUsers(): Promise<User[]> {
    const data = await this.get('/users');
    return data.map(user => {
      const result = UserCodec.decode(user);
      if (isLeft(result)) {
        throw new Error('Invalid user data from API');
      }
      return result.right;
    });
  }
}
```

### Form Validation
```typescript
// Use partial codecs for form validation
const UserFormCodec = t.partial({
  name: t.string,
  email: EmailString,
  age: t.number,
});

function validateUserForm(formData: unknown) {
  return validateData(UserFormCodec, formData);
}
```

### Data Processing Pipelines
```typescript
// Validate data at pipeline boundaries
function processUsers(rawData: unknown[]): User[] {
  return rawData
    .map(data => UserCodec.decode(data))
    .filter(isRight)
    .map(result => result.right);
}
```

## 🏗️ Architecture

DtoForge uses a plugin-based architecture:

```
┌─────────────────┐    ┌──────────────────┐    ┌────────────────────┐
│   OpenAPI       │    │  Intermediate    │    │    TypeScript      │
│   Parser        │────│  Representation  │────│    Generator       │
│                 │    │     (IR)         │    │    (io-ts)         │
└─────────────────┘    └──────────────────┘    └────────────────────┘
                                │
                                ├── Future: C# Generator
                                └── Future: Java Generator
```

This makes it easy to add support for other target languages in the future.

## 🤝 Contributing

We welcome contributions! Here's how to get started:

### Development Setup

```bash
# Clone the repository
git clone https://github.com/eliraz-refael/dtoForge.git
cd dtoforge

# Install dependencies
go mod download

# Run tests
go test ./...

# Build locally
go build -o dtoforge .
```

### Running Tests

```bash
# Unit tests
go test -v ./internal/...

# Integration tests
go test -v ./integration_test.go

# Golden file tests (creates baseline)
UPDATE_GOLDEN=true go test -v -run TestGoldenFilesWithUpdate

# All tests
go test -v ./...
```

### Adding New Features

1. **Fork** the repository
2. **Create** a feature branch: `git checkout -b feature/my-feature`
3. **Add tests** for your changes
4. **Run tests**: `go test ./...`
5. **Submit** a pull request

## 📋 Roadmap

- [ ] **C# Generator** - Generate C# classes with validation
- [ ] **Java Generator** - Generate Java POJOs with Bean Validation
- [ ] **Advanced OpenAPI Features** - Support for `allOf`, `oneOf`, `anyOf`
- [ ] **Configuration UI** - Web interface for creating custom type mappings
- [ ] **IDE Plugins** - VSCode extension for inline validation
- [ ] **JSON Schema Support** - Direct JSON Schema input
- [ ] **OpenAPI 3.1 Support** - Latest specification features

## 🐛 Troubleshooting

### Common Issues

**Q: Generated files have import errors**
```bash
# Make sure your branded-types.ts file exports the correct types
# Check the import paths in your config file
```

**Q: Validation always fails**
```typescript
// Check that your data structure matches the schema
console.log(UserCodec.decode(data)); // See detailed error information
```

**Q: Config file not found**
```bash
# DtoForge looks for config in these locations:
# 1. Current directory: ./dtoforge.config.yaml
# 2. Same directory as OpenAPI file
# 3. Same directory as binary
# Or specify explicitly: -config path/to/config.yaml
```

## 📄 License

MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- [io-ts](https://github.com/gcanti/io-ts) - Excellent runtime type validation library
- [fp-ts](https://github.com/gcanti/fp-ts) - Functional programming utilities
- The OpenAPI community for the great specification

---

**Made with ❤️ by developers, for developers**

*DtoForge helps you build type-safe applications by bridging the gap between API specifications and runtime validation.*
