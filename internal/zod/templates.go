package zod

// dtoTemplate generates individual DTO files with Zod schemas
const dtoTemplate = `// Generated by DtoForge (Zod) - DO NOT EDIT
{{range .Imports}}{{.}}
{{end}}

{{if .DTO.Description}}/**
 * {{.DTO.Description}}
 */
{{end}}{{if eq .DTO.Type "enum"}}// Enum: {{.DTO.Name}}
export const {{.DTO.Name}}Schema = z.enum([
{{range $i, $value := .DTO.EnumValues}}  '{{$value}}'{{if ne $i (len $.DTO.EnumValues | add -1)}},{{end}}
{{end}}]);

export type {{.DTO.Name}} = z.infer<typeof {{.DTO.Name}}Schema>;
{{else}}// Schema: {{.DTO.Name}}
export const {{.DTO.Name}}Schema = z.object({
{{range .DTO.Properties}}{{if hasDescription .Description}}  // {{.Description}}
{{end}}  {{toCamelCase .Name}}: {{toZodType .Type .Nullable (not .Required)}},
{{end}}});

export type {{.DTO.Name}} = z.infer<typeof {{.DTO.Name}}Schema>;
{{end}}
`

// indexTemplate generates the main index file that exports everything
const indexTemplate = `// Generated by DtoForge (Zod) - DO NOT EDIT
// {{.PackageName}} - OpenAPI Schema Validators

{{range .DTOs}}export * from './{{toKebabCase .Name}}';
{{end}}

// Re-export Zod for convenience
export { z } from 'zod';

// Utility type for validation results (similar to Zod's SafeParseReturnType)
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  error?: {
    issues: Array<{
      path: (string | number)[];
      message: string;
      code: string;
    }>;
  };
};

// Generic validation helper
export const validateData = <T>(
  schema: z.ZodSchema<T>,
  data: unknown
): ValidationResult<T> => {
  const result = schema.safeParse(data);

  if (result.success) {
    return {
      success: true,
      data: result.data,
    };
  }

  return {
    success: false,
    error: {
      issues: result.error.issues.map(issue => ({
        path: issue.path,
        message: issue.message,
        code: issue.code,
      })),
    },
  };
};

{{if .DTOs}}// All available schemas
export const schemas = {
{{range .DTOs}}  {{toCamelCase .Name}}: {{.Name}}Schema,
{{end}}};

// Schema names for runtime access
export const schemaNames = [
{{range .DTOs}}  '{{.Name}}',
{{end}}] as const;

export type SchemaName = typeof schemaNames[number];
{{end}}
`

// packageJSONTemplate generates a package.json for the generated code
const packageJSONTemplate = `{
  "name": "{{.PackageName}}",
  "version": "1.0.0",
  "description": "Generated TypeScript schemas with Zod validation",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "keywords": ["typescript", "zod", "validation", "openapi", "dto"],
  "license": "MIT"
}
`

// singleFileTemplate generates all DTOs in a single file
const singleFileTemplate = `// Generated by DtoForge (Zod) - DO NOT EDIT
// {{.PackageName}} - OpenAPI Schema Validators

{{range .Imports}}{{.}}
{{end}}

{{range .DTOs}}{{if .Description}}/**
 * {{.Description}}
 */
{{end}}{{if eq .Type "enum"}}// Enum: {{.Name}}
export const {{.Name}}Schema = z.enum([
{{range $i, $value := .EnumValues}}  '{{$value}}'{{if ne $i (len .EnumValues | add -1)}},{{end}}
{{end}}]);

export type {{.Name}} = z.infer<typeof {{.Name}}Schema>;

{{else}}// Schema: {{.Name}}
export const {{.Name}}Schema = z.object({
{{range .Properties}}{{if hasDescription .Description}}  // {{.Description}}
{{end}}  {{toCamelCase .Name}}: {{toZodType .Type .Nullable (not .Required)}},
{{end}}});

export type {{.Name}} = z.infer<typeof {{.Name}}Schema>;

{{end}}
{{end}}

{{if .GenerateHelpers}}// Re-export Zod for convenience
export { z } from 'zod';

// Utility type for validation results (similar to Zod's SafeParseReturnType)
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  error?: {
    issues: Array<{
      path: (string | number)[];
      message: string;
      code: string;
    }>;
  };
};

// Generic validation helper
export const validateData = <T>(
  schema: z.ZodSchema<T>,
  data: unknown
): ValidationResult<T> => {
  const result = schema.safeParse(data);

  if (result.success) {
    return {
      success: true,
      data: result.data,
    };
  }

  return {
    success: false,
    error: {
      issues: result.error.issues.map(issue => ({
        path: issue.path,
        message: issue.message,
        code: issue.code,
      })),
    },
  };
};

{{end}}{{if .DTOs}}// All available schemas
export const schemas = {
{{range .DTOs}}  {{toCamelCase .Name}}: {{.Name}}Schema,
{{end}}};

// Schema names for runtime access
export const schemaNames = [
{{range .DTOs}}  '{{.Name}}',
{{end}}] as const;

export type SchemaName = typeof schemaNames[number];
{{end}}`
