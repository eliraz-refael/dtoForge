package typescript

// dtoTemplate generates individual DTO files with io-ts codecs
const dtoTemplate = `// Generated by DtoForge - DO NOT EDIT
{{range .Imports}}{{.}}
{{end}}
{{if .DTO.Description}}
/**
 * {{.DTO.Description}}
 */
{{end}}{{if eq .DTO.Type "enum"}}// Enum: {{.DTO.Name}}
export const {{.DTO.Name}}Values = {
{{range $i, $value := .DTO.EnumValues}}  {{quote $value}}: null{{if ne $i (len $.DTO.EnumValues | add -1)}},{{end}}
{{end}}} as const;

export const {{.DTO.Name}}Codec = t.keyof({{.DTO.Name}}Values);

export type {{.DTO.Name}} = t.TypeOf<typeof {{.DTO.Name}}Codec>;

// Validation helper
export const is{{.DTO.Name}} = (value: unknown): value is {{.DTO.Name}} =>
  {{.DTO.Name}}Codec.is(value);

// Decode helper with error handling
export const decode{{.DTO.Name}} = (value: unknown) =>
  {{.DTO.Name}}Codec.decode(value);
{{else}}// Schema: {{.DTO.Name}}
export const {{.DTO.Name}}Codec = t.type({
{{range .DTO.Properties}}{{if hasDescription .Description}}  // {{.Description}}
{{end}}  {{toCamelCase .Name}}: {{if .Required}}{{toIoTsType .Type .Nullable}}{{else}}t.union([{{toIoTsType .Type .Nullable}}, t.undefined]){{end}},
{{end}}});

export type {{.DTO.Name}} = t.TypeOf<typeof {{.DTO.Name}}Codec>;

// Validation helper
export const is{{.DTO.Name}} = (value: unknown): value is {{.DTO.Name}} =>
  {{.DTO.Name}}Codec.is(value);

// Decode helper with error handling
export const decode{{.DTO.Name}} = (value: unknown) =>
  {{.DTO.Name}}Codec.decode(value);

// Partial codec for updates (all fields optional)
export const {{.DTO.Name}}PartialCodec = t.partial({
{{range .DTO.Properties}}  {{toCamelCase .Name}}: {{toIoTsType .Type .Nullable}},
{{end}}});

export type {{.DTO.Name}}Partial = t.TypeOf<typeof {{.DTO.Name}}PartialCodec>;
{{end}}
`

// indexTemplate generates the main index file that exports everything
const indexTemplate = `// Generated by DtoForge - DO NOT EDIT
// {{.PackageName}} - OpenAPI Schema Validators

{{range .DTOs}}export * from './{{toKebabCase .Name}}';
{{end}}

// Re-export io-ts for convenience
export * as t from 'io-ts';
export { isLeft, isRight } from 'fp-ts/Either';

// Utility type for validation results
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  errors?: string[];
};

// Generic validation helper
export const validateData = <T>(
  codec: t.Type<T, any, unknown>,
  data: unknown
): ValidationResult<T> => {
  const result = codec.decode(data);

  if (isRight(result)) {
    return {
      success: true,
      data: result.right,
    };
  }

  return {
    success: false,
    errors: formatValidationErrors(result.left),
  };
};

// Format io-ts validation errors into readable messages
const formatValidationErrors = (errors: t.Errors): string[] => {
  return errors.map(error => {
    const path = error.context.map(c => c.key).filter(key => key !== '').join('.');
    const expectedType = error.context[error.context.length - 1]?.type?.name || 'unknown';
    const actualValue = error.value;

    return path
      ? ` + "`" + `Invalid value at '${path}': expected ${expectedType}, got ${typeof actualValue}` + "`" + `
      : ` + "`" + `Invalid value: expected ${expectedType}, got ${typeof actualValue}` + "`" + `;
  });
};

{{if .DTOs}}// All available schemas
export const schemas = {
{{range .DTOs}}  {{toCamelCase .Name}}: {{.Name}}Codec,
{{end}}};

// Schema names for runtime access
export const schemaNames = [
{{range .DTOs}}  '{{.Name}}',
{{end}}] as const;

export type SchemaName = typeof schemaNames[number];
{{end}}
`

// packageJSONTemplate generates a package.json for the generated code
const packageJSONTemplate = `{
  "name": "{{.PackageName}}",
  "version": "1.0.0",
  "description": "Generated TypeScript schemas with io-ts validation",
  "main": "index.js",
  "types": "index.d.ts",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "io-ts": "^2.2.20",
    "io-ts-types": "^0.5.16",
    "fp-ts": "^2.16.1"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "keywords": ["typescript", "io-ts", "validation", "openapi", "dto"],
  "license": "MIT"
}
`

// singleFileTemplate generates all DTOs in a single file
const singleFileTemplate = `// Generated by DtoForge - DO NOT EDIT
// {{.PackageName}} - OpenAPI Schema Validators

{{range .Imports}}{{.}}
{{end}}

{{range .DTOs}}{{if .Description}}/**
 * {{.Description}}
 */
{{end}}{{if eq .Type "enum"}}// Enum: {{.Name}}
export const {{.Name}}Values = {
{{range $i, $value := .EnumValues}}  {{quote $value}}: null{{if ne $i (len $.EnumValues | add -1)}},{{end}}
{{end}}} as const;

export const {{.Name}}Codec = t.keyof({{.Name}}Values);

export type {{.Name}} = t.TypeOf<typeof {{.Name}}Codec>;

// Validation helper
export const is{{.Name}} = (value: unknown): value is {{.Name}} =>
  {{.Name}}Codec.is(value);

// Decode helper with error handling
export const decode{{.Name}} = (value: unknown) =>
  {{.Name}}Codec.decode(value);

{{else}}// Schema: {{.Name}}
export const {{.Name}}Codec = t.type({
{{range .Properties}}{{if hasDescription .Description}}  // {{.Description}}
{{end}}  {{toCamelCase .Name}}: {{if .Required}}{{toIoTsType .Type .Nullable}}{{else}}t.union([{{toIoTsType .Type .Nullable}}, t.undefined]){{end}},
{{end}}});

export type {{.Name}} = t.TypeOf<typeof {{.Name}}Codec>;

// Validation helper
export const is{{.Name}} = (value: unknown): value is {{.Name}} =>
  {{.Name}}Codec.is(value);

// Decode helper with error handling
export const decode{{.Name}} = (value: unknown) =>
  {{.Name}}Codec.decode(value);

{{if $.GeneratePartialCodecs}}// Partial codec for updates (all fields optional)
export const {{.Name}}PartialCodec = t.partial({
{{range .Properties}}  {{toCamelCase .Name}}: {{toIoTsType .Type .Nullable}},
{{end}}});

export type {{.Name}}Partial = t.TypeOf<typeof {{.Name}}PartialCodec>;

{{end}}{{end}}
{{end}}

{{if .GenerateHelpers}}// Re-export io-ts for convenience
export * as t from 'io-ts';
export { isLeft, isRight } from 'fp-ts/Either';

// Utility type for validation results
export type ValidationResult<T> = {
  success: boolean;
  data?: T;
  errors?: string[];
};

// Generic validation helper
export const validateData = <T>(
  codec: t.Type<T, any, unknown>,
  data: unknown
): ValidationResult<T> => {
  const result = codec.decode(data);

  if (isRight(result)) {
    return {
      success: true,
      data: result.right,
    };
  }

  return {
    success: false,
    errors: formatValidationErrors(result.left),
  };
};

// Format io-ts validation errors into readable messages
const formatValidationErrors = (errors: t.Errors): string[] => {
  return errors.map(error => {
    const path = error.context.map(c => c.key).filter(key => key !== '').join('.');
    const expectedType = error.context[error.context.length - 1]?.type?.name || 'unknown';
    const actualValue = error.value;

    return path
      ? ` + "`" + `Invalid value at '${path}': expected ${expectedType}, got ${typeof actualValue}` + "`" + `
      : ` + "`" + `Invalid value: expected ${expectedType}, got ${typeof actualValue}` + "`" + `;
  });
};

{{end}}{{if .DTOs}}// All available schemas
export const schemas = {
{{range .DTOs}}  {{toCamelCase .Name}}: {{.Name}}Codec,
{{end}}};

// Schema names for runtime access
export const schemaNames = [
{{range .DTOs}}  '{{.Name}}',
{{end}}] as const;

export type SchemaName = typeof schemaNames[number];
{{end}}`
